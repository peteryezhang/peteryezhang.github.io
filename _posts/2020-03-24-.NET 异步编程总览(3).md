---
layout:     post                    # 使用的布局（不需要改）
title:      .NET 异步编程总览(3)           # 标题 
subtitle:   取消任务的最佳实践  #副标题
date:       2020-03-24              # 时间
author:     Peter                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - .NET
    - Parallel
---

## 前言

TAP编程中使用`CancellationToken`来实现任务的取消。  
本篇内容将会聚焦在`CancellationToken` 与 `Task.WhenAny`/`Task.WhenAll`方法在取消一个或者多个任务时的最佳实践。  

## 取消一个或多个Task

### 取消一个Task

首先我们需要初始化一个`CancellationTokenSource`
```
public partial class MainWindow : Window
{
    // ***Declare a System.Threading.CancellationTokenSource.
    CancellationTokenSource cts;
    cts = new CancellationTokenSource();

```
然后我们需要一个event handler来触发token的取消操作`CancellationTokenSource.Cancel`
```
// ***Add an event handler for the Cancel button.
private void cancelButton_Click(object sender, RoutedEventArgs e)
{
    if (cts != null)
    {
        cts.Cancel();
    }
}
```
最后是我们的async task，并向其中传入`CancellationTokenSource.Token`来响应取消操作
值得注意的是，对于取消操作的响应是在`try/catch`中对`OperationCanceledException`异常的捕捉之后进行的。
```
try
{
    // ***Send a token to carry the message if cancellation is requested.
    int contentLength = await AccessTheWebAsync(cts.Token);
    resultsTextBox.Text += $"\r\nLength of the downloaded string: {contentLength}.\r\n";
}
// *** If cancellation is requested, an OperationCanceledException results.
catch (OperationCanceledException)
{
    resultsTextBox.Text += "\r\nDownload canceled.\r\n";
}
catch (Exception)
{
    resultsTextBox.Text += "\r\nDownload failed.\r\n";
}
```
