---
layout:     post                    # 使用的布局（不需要改）
title:     ASP.NET Core学习笔记     # 标题 
subtitle:     #副标题
date:       2020-07-16             # 时间
author:     Peter                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - .NET Core
    
---


## ASP.NET Core启动类

ASP.NET Core中以`Program.cs`作为主程序入口，并使用类似  

```
            var host = new WebHostBuilder()
                .UseKestrel(options => options.AddServerHeader = false)
                .UseContentRoot(Directory.GetCurrentDirectory())
                .UseIISIntegration()
                .UseStartup<Startup>()
                .Build();

            host.Run();
```  

启动应用程序。  

在`Startup.cs`中， 存在`Startup()`构造方法，`ConfigureServices()`,`Configure()`三个启动方法。  

一般的，我们会在`ConfigureServices()`中进行服务注册（MVC,服务认证，鉴权etc），在`Configure()`中决定哪些中间件。  

## ASP.NET Core依赖注入框架

ASP.NET Core的整个架构中，依赖注入框架提供了对象创建和生命周期管理的核心能力。各个组件相互协作也是通过依赖注入框架实现。  

### 核心的Dependency: 

+ `Microsoft.Extensions.DependencyInjection`

+ `Microsoft.Extensions.DependencyInjection.Abstractions`  

### 核心类型  

+ `IServiceCollection`: 服务的注册，在`StartUp.cs ConfigureServices()`中通过`service.Add()`操作
+ `ServiceDescriptor`： 描述服务注册的具体信息
+ `IServiceProvider`: 具体的容器
+ `IServiceScope`: 容器的生命周期  

### 服务实例的获取 

1. 在Controller的构造函数中注入，适用于Controller中大部分接口都需用到的情况：
```
public AccountController(IConfiguration configuration, IService caseService)
```  
2. `[FromService]`: 适用于仅有某一个接口使用的场景

### 服务的生命周期

+ `Singleton` : 经典单例模式
+ `Transient`： 瞬时模式，每次调用均创建新的服务实例
+ `Scope`： 作用域模式，可在每次Context请求中创建一个服务实例  

### 容器管理的对象的释放

对于实现了`IDisposable`接口的对象来说：

+ DI 只负责释放由其创建的对象实例
+ DI 在容器或者子容器释放时，才会释放由其创建的对象实例  

**尽量不要在根容器创建Transient类型的实现了IDisposable接口的服务实例**  

### 第三方容器 AutoFac

ASP.NET Core中的容器核心扩展点是`public interface IServiceProviderFactory<TContainerBuilder>`， 所有第三方扩展容器都要实现该接口。  

使用AutoFac,我们可以在ASP.NET Core中实现：

+ 属性注册
+ 方法注册
+ AOP注册

#### 属性注入

属性注入 使用可写属性而不是构造方法参数来完成注入。  

如果组件是一个 lambda表达式组件, 使用对象构造器:  

```
builder.Register(c => new A { B = c.Resolve<B>() });

```

#### 方法注入

想要调用一个方法来设置组件上的某个值, 最简单的方法是使用 lambda表达式组件 然后在activator中进行正确的方法调用:  

```
builder.Register(c => {
  var result = new MyObjectType();
  var dep = c.Resolve<TheDependency>();
  result.SetTheDependency(dep);
  return result;
});
```

#### AOP注入

Autofac实现AOP最核心的接口是`IInterceptor`,一个简单的日志注入的实现如下:  

```
public class CallLogger : IInterceptor
{
  TextWriter _output;

  public CallLogger(TextWriter output)
  {
    _output = output;
  }

  public void Intercept(IInvocation invocation)
  {
    _output.Write("Calling method {0} with parameters {1}... ",
      invocation.Method.Name,
      string.Join(", ", invocation.Arguments.Select(a => (a ?? "").ToString()).ToArray()));

    invocation.Proceed();

    _output.WriteLine("Done: result was {0}.", invocation.ReturnValue);
  }
}
```  

## ASP.NET Core配置框架

ASP.NET Core中配置框架的核心包有两个：
+ `Microsoft.Extensions.Configuration.Abstractions`
+ `Microsoft.Extensions.Configuration`

配置文件主要以`key-value`字符串键值对的方式抽象配置，并支持从不同数据源读取配置。  

### 核心类型  

+ `IConfiguration`: 
+ `IConfigurationRoot`： 配置的root,读取配置的操作都需要从此进入
+ `IConfigurationSection`: 需要使用Section来将配置分组时使用
+ `IConfigurationBuilder`: 用来接收具体的配置

```
var builder = new ConfigurationBuilder()
    .SetBasePath(environment.ContentRootPath)
    .AddJsonFile("appsettings.json", true, true)

Configuration = builder.Build();
```

### 核心扩展点

+ `IConfigurationSource`: 指定配置数据来源
+ `IConfigurationProvider`: 指定配置的提供者  

### 多来源的配置初始化

+ 命令行的配置初始化： 略
+ 环境变量的配置初始化： Docker/Kubernetes/内置特殊配置(是否是开发环境)
```
    builder.AddEnvironmentVariables();

```
+ 
